from numpy import linalg
import numpy as np
from cla_utils.exercises4 import operator_2_norm
from numpy import random
from cla_utils.exercises3 import householder_qr


def randomQ(m):
    """
    Produce a random orthogonal mxm matrix.

    :param m: the matrix dimension parameter.
    
    :return Q: the mxm numpy array containing the orthogonal matrix.
    """
    Q, R = np.linalg.qr(random.randn(m, m))
    return Q


def randomR(m):
    """
    Produce a random upper triangular mxm matrix.

    :param m: the matrix dimension parameter.
    
    :return R: the mxm numpy array containing the upper triangular matrix.
    """
    
    A = random.randn(m, m)
    return np.triu(A)


def backward_stability_householder(m):
    """
    Verify backward stability for QR factorisation using Householder for
    real mxm matrices.

    :param m: the matrix dimension parameter.
    """
    # repeat the experiment a few times to capture typical behaviour
    for k in range(20):
        Q1 = randomQ(m)
        R1 = randomR(m)
        A = np.dot(Q1, R1)
        Q2, R2 = np.linalg.qr(A)
        Q2Q1 = operator_2_norm(Q2 - Q1)
        R2R1 = operator_2_norm(R2 - R1)
        A_Q2R2 = operator_2_norm(A - np.dot(Q2, R2))
        k = k+1
        print (Q2Q1, R2R1, A_Q2R2)
    """
    Explain: From the function, we can find that the value of ||A-Q2R2|| is much smaller when compared with the others. 
    The Householder algorithm is backward stable.
    """


def solve_R(R, b):
    """
    Solve the system Rx=b where R is an mxm upper triangular matrix 
    and b is an m dimensional vector.

    :param A: an mxm-dimensional numpy array
    :param b: an m-dimensional numpy array

    :param x: an m-dimensional numpy array
    """
    m, n = R.shape
    x = np.zeros((m), dtype = R.dtype)
    for i in range(m -1, -1, -1):
        d = np.dot(R[i, i+1:m], x[i +1:m])     
        x[i] = (b[i] - d) / R[i, i]
    return x              


def back_stab_solve_R(m):
    """
    Verify backward stability for back substitution for
    real mxm matrices.

    :param m: the matrix dimension parameter.
    """
    # repeat the experiment a few times to capture typical behaviour
    
    for k in range(20):
        A = random.randn(m, m)
        b = random.randn(m)
        """
        R = np.triu(A)
        b = random.randn(m)
        """
        Q, R = householder_qr(A)
        Q_T = np.conjugate(Q).T
        y = np.dot(Q_T, b)
        x = solve_R(R, y)
        diff = np.dot(A, x) - b
        error = np.sqrt(np.dot(np.conjugate(diff), diff))
        print(error)

    raise NotImplementedError


def back_stab_householder_solve(m):
    """
    Verify backward stability for the householder algorithm
    for solving Ax=b for an m dimensional square system.

    :param m: the matrix dimension parameter.
    """
    raise NotImplementedError
