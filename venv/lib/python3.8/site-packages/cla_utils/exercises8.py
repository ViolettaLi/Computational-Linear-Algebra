import numpy as np
from numpy import linalg
from cla_utils.exercises3 import householder_qr

def Q1AQ1s(A):
    """
    For a matrix A, find the unitary matrix Q1 such that the first
    column of Q1*A has zeros below the diagonal. Then return A1 = Q1*A*Q1^*.

    :param A: an mxm numpy array

    :return A1: an mxm numpy array
    """
    x = A[:, 0]
    l = len(x)
    e = np.zeros(l, dtype = x.dtype)
    e[0] = 1
    v_ini = np.sign(x[0]) * np.linalg.norm(x) * e + x
    v = v_ini / np.linalg.norm(v_ini)
    v_conj = np.conjugate(v)
    A = A - 2 * np.outer(v, np.dot(v_conj, A))
    A = A - 2 * np.outer(np.dot(A, v), v_conj)
    return A


def hessenberg(A):
    """
    For a matrix A, transform to Hessenberg form H by Householder
    similarity transformations, in place.

    :param A: an mxm numpy array
    """
    m, n = A.shape
    for k in range(1,m-1):
        x = A[k:, k - 1]
        l = len(x)
        e = np.zeros(l, dtype = x.dtype)
        e[0] = 1
        vk_ini = np.sign(x[0]) * np.linalg.norm(x) * e + x
        vk = vk_ini / np.linalg.norm(vk_ini)
        vk_conj = np.conjugate(vk)
        A[k:, k - 1:] = A[k:, k - 1:] - 2 * np.outer(vk, np.dot(vk_conj, A[k:, k - 1:]))
        A[:, k:] = A[:, k:] - 2 * np.outer(np.dot(A[:, k:], vk), vk_conj)
    return A


def hessenbergQ(A):
    """
    For a matrix A, transform to Hessenberg form H by Householder
    similarity transformations, in place, and return the matrix Q
    for which QHQ^* = A.

    :param A: an mxm numpy array
    
    :return Q: an mxm numpy array
    """
    m, n = A.shape
    Q = np.identity(m)
    for k in range(1, m-1):
        x = A[k:, k - 1]
        l = len(x)
        e = np.zeros(m-k, dtype = x.dtype)
        e[0] = 1
        vk_ini = np.sign(x[0]) * np.linalg.norm(x) * e + x
        vk = vk_ini / np.linalg.norm(vk_ini)
        vk_conj = np.conjugate(vk)
        A[k:, k - 1:] = A[k:, k - 1:] - 2 * np.outer(vk, np.dot(vk_conj, A[k:, k - 1:]))
        A[:, k:] = A[:, k:] - 2 * np.outer(np.dot(A[:, k:], vk), vk_conj)
        Q[:, k:] = Q[:, k:] - 2 * np.outer(np.dot(Q[:, k:], vk), vk_conj)
    return Q


def hessenberg_ev(H):
    """
    Given a Hessenberg matrix, return the eigenvalues and eigenvectors.

    :param H: an mxm numpy array

    :return ee: an m dimensional numpy array containing the eigenvalues of H
    :return V: an mxm numpy array whose columns are the eigenvectors of H
    """
    m, n = H.shape
    assert(m==n)
    assert(np.linalg.norm(H[np.tril_indices(m, -2)]) < 1.0e-6)
    _, V = np.linalg.eig(H)
    return V


def ev(A):
    """
    Given a matrix A, return the eigenvectors of A. This should
    be done by using your functions to reduce to upper Hessenberg
    form, before calling hessenberg_ev (which you should not edit!).

    :param A: an mxm numpy array

    :return V: an mxm numpy array whose columns are the eigenvectors of A
    """
    Q = hessenbergQ(A)
    H_ev = hessenberg_ev(A)
    V = np.dot(Q, H_ev)
    return V
