import numpy as np


def operator_2_norm(A):
    """
    Given a real mxn matrix A, return the operator 2-norm.

    :param A: an mxn-dimensional numpy array

    :return o2norm: the norm
    """
    AA = (np.conjugate(A).T).dot(A)
    e_values =  np.linalg.eig(AA)[0]
    e_value = np.max(e_values)
    o2norm = np.sqrt(e_value)
    return o2norm


from numpy import random
def verify_1(m, n):
    random.seed(1878*m + 1950*n)
    A = random.randn(m, n)
    x = random.randn(n) + random.randn(n) * 1j
    A_x = A.dot(x)
    norm_A = operator_2_norm(A)
    norm_x = np.sqrt(np.dot(np.conjugate(x).T, x))
    norm_Ax = np.sqrt(np.dot(np.conjugate(A_x).T, A_x))
    if norm_Ax <= norm_A * norm_x:
        result = True
    else:
        result = False
    return result


def verify_2(m, n, l):
    result = True
    for i in range(100):
        """
        m = random.randint(1,100)
        n = random.randint(1,100)
        """
        A = np.random.randint(1, 100, (l, m)) + np.random.randint(1, 100, (l, m)) * 1j
        B = np.random.randint(1, 100, (m, n)) + np.random.randint(1, 100, (m, n)) * 1j
        A_inm = operator_2_norm(A)
        B_inm = operator_2_norm(B)
        AB_inm = operator_2_norm(np.inner(A, B))
        if AB_inm <= A_inm * B_inm:
            result = result
        else:
            result = False
    return result


def cond(A):
    """
    Given a real mxn matrix A, return the condition number in the 2-norm.

    :return A: an mxn-dimensional numpy array

    :param ncond: the condition number
    """
    m, n = A.shape
    A_transform = A.T
    AA = A_transform.dot(A)
    e = np.sqrt(np.linalg.eig(AA)[0])
    e_1 = np.max(e)
    e_2 = np.min(e)
    ncond = e_1 / e_2

    return ncond
