import numpy as np
import timeit
from numpy import random


def get_Lk(m, lvec):
    """Compute the lower triangular row operation mxm matrix L_k 
    which has ones on the diagonal, and below diagonal entries
    in column k given by lvec (k is inferred from the size of lvec).
    :param m: integer giving the dimensions of L.
    :param lvec: a m-k dimensional numpy array.
    :return Lk: an mxm dimensional numpy array.
    """
    I = np.identity(m)
    k = m - len(lvec)
    Lk = I
    Lk[k:m, k-1] = -lvec
    return Lk


# 3 loop LUinplace, the vectorized one which only has one loop are shown in next function
def LU_inplace(A):
    """Compute the LU factorisation of A, using the in-place scheme so
    that the strictly lower triangular components of the array contain
    the strictly lower triangular components of L, and the upper
    triangular components of the array contain the upper triangular
    components of U.

    :param A: an mxm-dimensional numpy array

    """
    U = 1*A  
    m, n = A.shape
    L = np.identity(m)  
    for k in range(m - 1):
        for j in range(k + 1, m):
            L[j, k] = U[j, k] / U[k, k]
            U[j, k + 1:] = U[j, k + 1:] - np.dot(L[j, k], U[k, k + 1:])
    for i in range(m):
        A[i, i:] = U[i, i:]
        A[i, :i] = L[i, :i]

# 1 loop algorithm
def LU_inplace_new(A):
    m, n = A.shape
    for i in range(m - 1):
        A[i + 1:, i] = A[i + 1:, i] / A[i ,i]
        A[i + 1:, i + 1:] = A[i + 1:, i + 1:] - np.outer(A[i + 1:, i], A[i, i + 1:])
    return A


import timeit
def test_time_LU_inplace(m):
    A = random.randn(m, m) 
    
    def test_3loop():
        LU_inplace(A)
    
    def test_1loop():
        LU_inplace_new(A)    
    LU_inplace(A)
    LU_inplace_new(A)
    time3 = timeit.timeit(test_3loop, number = 1)
    time1 = timeit.timeit(test_1loop, number = 1)
    print("dim = %4d, LU3: %.5f, LU1: %.5f, upspeed = %2.2f"%
         (m, time3, time1, time3 / time1))

# Calculate the speed when the matrix size is 10, 100, 1000, to find out the difference between this 2 functions.
test_time_LU_inplace(10)
test_time_LU_inplace(100)
#test_time_LU_inplace(1000)

"""
Speed: The original three-loop function took much longer time to run than the new function which only has one loop.
"""


def solve_L(L, b):
    """
    Solve systems Lx_i=b_i for x_i with L lower triangular, i=1,2,...,k

    :param L: an mxm-dimensional numpy array, assumed lower triangular
    :param b: an mxk-dimensional numpy array, with ith column containing 
       b_i
    :return x: an mxk-dimensional numpy array, with ith column containing 
       the solution x_i

    """
    m, k = b.shape
    b_copy = b.copy()
    x = np.zeros((m, k), dtype = b.dtype)
    x[0] = b_copy[0] / L[0, 0]
    for i in range(m - 1):
        x[i + 1] = (b_copy[i + 1] - np.dot(L[i + 1, :i + 1], x[:i + 1]))/L[i + 1, i + 1]
    return x





def solve_U(U, b):
    """
    Solve systems Ux_i=b_i for x_i with U upper triangular, i=1,2,...,k

    :param U: an mxm-dimensional numpy array, assumed upper triangular
    :param b: an mxk-dimensional numpy array, with ith column containing 
       b_i
    :return x: an mxk-dimensional numpy array, with ith column containing 
       the solution x_i

    """
    m, k = b.shape
    b_copy = b.copy()
    x = np.zeros((m, k), dtype = b.dtype)
    x[-1] = b_copy[-1] / U[-1, -1]
    for i in range(m - 3, -2, -1):
        x[i + 1] = (b_copy[i + 1] - np.dot(U[i + 1, i + 1:], x[i + 1:]))/U[i + 1, i + 1]       
    return x


def inverse_LU(A):
    """
    Form the inverse of A via LU factorisation.

    :param A: an mxm-dimensional numpy array.

    :return Ainv: an mxm-dimensional numpy array.

    """
    m, k = A.shape
    I = np.identity(m)
    new_A = LU_inplace_new(A)
    L = np.eye(m)
    i1 = np.tril_indices(m, k=-1)
    L[i1] = new_A[i1]
    #L = np.identity(m) + np.tril(new_A, -1)
    U = np.triu(new_A)
    Ainv = solve_U(U,solve_L(L, I))
    return Ainv



