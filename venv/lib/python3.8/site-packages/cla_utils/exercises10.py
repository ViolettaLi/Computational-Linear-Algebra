import numpy as np
import numpy.random as random
from numpy import linalg
from cla_utils.exercises3 import householder_ls


def arnoldi(A, b, k):
    """
    For a matrix A, apply k iterations of the Arnoldi algorithm,
    using b as the first basis vector.

    :param A: an mxm numpy array
    :param b: m dimensional numpy array, the starting vector
    :param k: integer, the number of iterations

    :return Q: an mx(k+1) dimensional numpy array containing the orthonormal basis
    :return H: a (k+1)xk dimensional numpy array containing the upper \
    Hessenberg matrix
    """
    m, m = A.shape
    Q = np.zeros((m, k + 1), dtype = A.dtype)
    H = np.zeros((k + 1, k), dtype = A.dtype)
    Q[:, 0] = b/np.linalg.norm(b)
    for j in range(k):
        v = np.dot(A, Q[:, j])
        H[:, j] = np.dot(np.conjugate(Q).T, v)
        v = v - np.dot(Q, H[:, j])
        H[j + 1, j] = np.linalg.norm(v)
        if H[j + 1, j] == 0:
            return Q, H
        Q[:, j + 1] = v/H[j + 1, j]
    return Q, H


def GMRES(A, b, maxit, tol, x0=None, return_residual_norms=False,
          return_residuals=False):
    """
    For a matrix A, solve Ax=b using the basic GMRES algorithm.

    :param A: an mxm numpy array
    :param b: m dimensional numpy array
    :param maxit: integer, the maximum number of iterations
    :param tol: floating point number, the tolerance for termination
    :param x0: the initial guess (if not present, use b)
    :param return_residual_norms: logical
    :param return_residuals: logical

    :return x: an m dimensional numpy array, the solution
    :return nits: if converged, the number of iterations required, otherwise \
    equal to -1
    :return rnorms: nits dimensional numpy array containing the norms of \
    the residuals at each iteration
    :return r: mxnits dimensional numpy array, column k contains residual \
    at iteration k
    """
    """
    if x0 is None:
        x0 = b
    m, m = A.shape
    Q = np.zeros((m, maxit + 1), dtype = A.dtype)
    H = np.zeros((maxit + 1, maxit), dtype = A.dtype)
    Q[:, 0] = b/np.linalg.norm(b)
    rnorms = []
    #r = []
    rs = np.array([np.zeros(m, dtype = A.dtype)])
    for j in range(maxit):
        v = np.dot(A, Q[:, j])
        H[:, j] = np.dot(np.conjugate(Q).T, v)
        v = v - np.dot(Q, H[:, j])
        H[j + 1, j] = np.linalg.norm(v)
        Q[:, j + 1] = v/H[j + 1, j]

        bl = np.zeros(j + 2, dtype = b.dtype)
        bl[0] = np.linalg.norm(b)
        Hj = H[:j + 2, :j + 1]
        y = householder_ls(Hj, bl)
        x0 = np.dot(Q[:, :j + 1], y)
        rv = np.dot(Hj, y) - bl
        rnorm = np.linalg.norm(rv)
        rnorms.append(rnorm)
        nits = j + 1
        #r.append(rv)
        rs = np.concatenate((rs, np.array([rv])))
        if rnorm < tol:
            break
    r = rs[1:, :].T
    if return_residual_norms == True and return_residuals == True:
        return x0, nits, rnorms, r
    else:
        return x0, nits
        """
    
    if x0 is None:
        x0 = b
    m, m = A.shape
    Q = np.zeros((m, maxit + 1), dtype = A.dtype)
    H = np.zeros((maxit + 1, maxit), dtype = A.dtype)
    Q[:, 0] = x0/np.linalg.norm(x0)
    nits = 0
    rnorms = np.array([])
    r = np.array([np.zeros(m, dtype = A.dtype)])
    for j in range(maxit):
        v = np.dot(A, Q[:, j])
        H[:, j] = np.dot(np.conjugate(Q).T, v)
        v = v - np.dot(Q, H[:, j])
        H[j + 1, j] = np.linalg.norm(v)
        Q[:, j + 1] = v/H[j + 1, j]
        Hj = H[:j + 2, :j + 1]
        bl = np.linalg.norm(b) * np.squeeze(np.eye(j + 2, 1))
        #bl = np.zeros(j + 2, dtype = b.dtype)
        y = householder_ls(Hj, bl)
        x = np.dot(Q[:, :j + 1], y)
        rv = np.dot(A, x) - b
        rnorm = np.linalg.norm(rv)
        rnorms = np.append(rnorms, rnorm)
        r = np.concatenate((r, np.array([rv])))
        nits = nits + 1
        if rnorm < tol:
            break
    r = r[1:, :].T
    if return_residual_norms == True and return_residuals == True:
        return x, nits, rnorms, r
    else:
        return x, nits


def get_AA100():
    """
    Get the AA100 matrix.

    :return A: a 100x100 numpy array used in exercises 10.
    """
    AA100 = np.fromfile('AA100.dat', sep=' ')
    AA100 = AA100.reshape((100, 100))
    return AA100


def get_BB100():
    """
    Get the BB100 matrix.

    :return B: a 100x100 numpy array used in exercises 10.
    """
    BB100 = np.fromfile('BB100.dat', sep=' ')
    BB100 = BB100.reshape((100, 100))
    return BB100


def get_CC100():
    """
    Get the CC100 matrix.

    :return C: a 100x100 numpy array used in exercises 10.
    """
    CC100 = np.fromfile('CC100.dat', sep=' ')
    CC100 = CC100.reshape((100, 100))
    return CC100
