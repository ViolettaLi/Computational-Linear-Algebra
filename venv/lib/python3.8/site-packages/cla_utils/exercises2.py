import numpy as np


def orthog_cpts(v, Q):
    """
    Given a vector v and an orthonormal set of vectors q_1,...q_n,
    compute v = r + u_1q_1 + u_2q_2 + ... + u_nq_n
    for scalar coefficients u_1, u_2, ..., u_n and
    residual vector r

    :param v: an m-dimensional numpy array
    :param Q: an mxn-dimensional numpy array whose columns are the \
    orthonormal vectors

    :return r: an m-dimensional numpy array containing the residual
    :return u: an n-dimensional numpy array containing the coefficients
    """
    r = v.copy()
    u = list()
    n = len(Q[0])
    for i in range(0, n):
        q_i = Q[:, i]
        q_star = np.conjugate(q_i)
        q_star_v = q_star.dot(v)
        r = r - np.inner(q_star_v, q_i)
        u.append(q_star_v)
    u = np.array(u)


    return r, u


def solveQ(Q, b):
    """
    Given a unitary mxm matrix Q and a vector b, solve Qx=b for x.

    :param Q: an mxm dimensional numpy array containing the unitary matrix
    :param b: the m dimensional array for the RHS

    :return x: m dimensional array containing the solution.
    """
    Q1 = np.transpose(Q)
    Q_star = np.conjugate(Q1)
    x = np.inner(Q_star,b)

    return x


def orthog_proj(Q):
    """
    Given a vector v and an orthonormal set of vectors q_1,...q_n,
    compute the orthogonal projector P that projects vectors onto
    the subspace spanned by those vectors.
    :param Q: an mxn-dimensional numpy array whose columns are the \
    orthonormal vectors

    :return P: an mxm-dimensional numpy array containing the projector
    """
    Q1 = np.transpose(Q)
    Q_star = np.conjugate(Q1)
    P = Q.dot(Q_star)


    return P


def orthog_space(V):
    """
    Given set of vectors u_1,u_2,..., u_n, compute the
    orthogonal complement to the subspace U spanned by the vectors.

    :param V: an mxn-dimensional numpy array whose columns are the \
    vectors u_1,u_2,...,u_n.

    :return Q: an mxl-dimensional numpy array whose columns are an \
    orthonormal basis for the subspace orthogonal to U, for appropriate l.
    """
    n = len(V[0])
    m = len(V[:, 0])
    qc, rc = np.linalg.qr(V, 'complete')
    Q = qc[:, n:]

    return Q


def GS_classical(A):
    """
    Given an mxn matrix A, compute the QR factorisation by classical
    Gram-Schmidt algorithm, transforming A to Q in place and returning R.

    :param A: mxn numpy array

    :return R: nxn numpy array
    """
    Q = A
    Q_conjugate = np.conjugate(Q)
    m = len(A[0])
    R = np.zeros((m, m), dtype = A.dtype)
    for j in range(1,m+1):
        k = j-1
        R[:k, j-1] = np.einsum('ij,i->j', Q_conjugate, A[:, j-1])[:k]
        v_j = A[:, j-1] - np.inner(R[:, j-1], Q)
        R[j-1, j-1] = np.sqrt((np.conjugate(v_j).dot(v_j)))
        Q[:, j-1] = v_j / R[j-1, j-1]

    return R

#def GS_modified(A):
    """
    Given an mxn matrix A, compute the QR factorisation by modified
    Gram-Schmidt algorithm, transforming A to Q in place and returning
    R.

    :param A: mxn numpy array

    :return R: nxn numpy array
    """
    """
    n = len(A[0])
    m = len(A[:, 0])
    R = np.zeros((n, n), dtype = A.dtype)
    V = np.zeros((m, n), dtype = A.dtype)
    Q = A
    for i in range(n):
        V[:, i] = A[:, i]

    for i in range(n):
        R[i, i] =np.sqrt(V[:, i].dot(V[:, i]))
        Q[:, i] = V[:, i] / R[i, i]
        for j in range(i+1, n):
            R[i, j] = np.dot(Q[:, i].T, V[:, j])
            V[:, j] = V[:, j] - R[i, j] * Q[:, i]

    return R
    """
def GS_modified(A):
    m, n = A.shape
    Q = A
    R = np.zeros((n, n), dtype = A.dtype)
    V = A.copy()
    for i in range(n):
        R[i, i] = np.linalg.norm(V[:, i])
        Q[:, i] = V[:, i] / R[i, i]
        R[i, (i + 1):] = np.dot(np.conjugate(Q[:, i]).T, V[:, (i + 1):])
        V[:, (i + 1):] = V[:, (i + 1):] - np.outer(Q[:, i], R[i, (i + 1):])
    return R


def GS_modified_get_R(A, k):
    """
    Given an mxn matrix A, with columns of A[:, 0:k] assumed orthonormal,
    return upper triangular nxn matrix R such that
    Ahat = A*R has the properties that
    1) Ahat[:, 0:k] = A[:, 0:k],
    2) A[:, k] is normalised and orthogonal to the columns of A[:, 0:k].

    :param A: mxn numpy array
    :param k: integer indicating the column that R should orthogonalise

    :return R: nxn numpy array
    """
    n = len(A[0]) 
    m = len(A[:, 0]) 
    R = np.identity(n, dtype = A.dtype)
    for i in range(k-1, n):
        R[k, i] = np.sqrt(A[i].dot(A[i]))  / np.sqrt(A[k-1].dot(A[k-1])) 

    return R

def GS_modified_R(A):
    """
    Implement the modified Gram Schmidt algorithm using the lower triangular
    formulation with Rs provided from GS_modified_get_R.

    :param A: mxn numpy array

    :return Q: mxn numpy array
    :return R: nxn numpy array
    """

    m, n = A.shape
    A = 1.0 * A
    R = np.eye(n, dtype=A.dtype)
    for i in range(n):
        Rk = GS_modified_get_R(A, i)
        A[:,:] = np.dot(A, Rk)
        R[:,:] = np.dot(R, Rk)
    R = np.linalg.inv(R)
    return A, R